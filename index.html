<html>

<head>
    <title>Demo: Processing of HLS Stream</title>
    <script src="https://hls-js.netlify.app/dist/hls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.3/dist/Chart.min.js"></script>
</head>

<body>

<div style="text-align: center">
    <video id="video" style="width: 50%" controls></video>
    <input type="text" style="width: 50%; border: solid 1px black; margin-top: 5px; font-size: 20px"
           placeholder="Stream link" id="url">
    <input type="button" value="Apply" style="border: solid 1px #000000; font-size: 20px" id="set_url">
    <input type="checkbox" id="highlightState"> Highlight Speaker
    <p id="subtitles" style="border-top: 1px solid grey"></p>
</div>
<div id="charts" style="border-top: 1px solid grey">
    <div style="height: 300px; width: 533px">
        <canvas id="myChart" style="height: 300px; width: 533px"></canvas>
    </div>
</div>
<script>
    let chart;

    let colors = {
        1: 'blue',
        3: 'red',
        100: 'green'
    };

    let text = [];
    let emotions = [];

    if (Hls.isSupported()) {
        var video = document.getElementById('video');
        var hls = new Hls();
        hls.loadSource('https://storage.googleapis.com/otopia_audio/conanZoom/ConanZoom.m3u8');
        hls.attachMedia(video);
        loadJSON('jdata.json', function (json) {
            let results = JSON.parse(json);
            for (let i = 0; i < results.length; i++) {
                emotions.push({
                    original: results[i].frame[0].ts,
                    ts: parseTs(results[i].frame[0].ts),
                    data: results[i].emotions[0]
                });
            }
        });

        function parseTs(ts) {
            let splitted = ts.split(':');
            let minutes = parseFloat(splitted[1].replace('0', ''));
            let tempSec = splitted[2].split('.');
            let seconds = parseFloat(tempSec[0].replace('0', ''));
            let milliseconds = parseFloat(tempSec[1].slice(0, -1));
            return parseFloat((minutes * 60 + seconds) + '.' + milliseconds);
        }

        loadJSON('ConanZoomTranscript.json', function (json) {
            let results = JSON.parse(json).response.results;
            let alternatives = results[results.length - 1].alternatives;
            for (let alternativeIndex = 0; alternativeIndex < alternatives.length; alternativeIndex++) {
                let words = alternatives[alternativeIndex].words;
                for (let wordIndex = 0; wordIndex < words.length; wordIndex++) {
                    text.push({
                        startTime: parseFloat(words[wordIndex].startTime.replace('s', '')),
                        endTime: parseFloat(words[wordIndex].endTime.replace('s', '')),
                        word: words[wordIndex].word,
                        speakerTag: words[wordIndex].speakerTag === undefined ? 100 : words[wordIndex].speakerTag
                    });
                }
            }
        })
        hls.on(Hls.Events.MANIFEST_PARSED, function () {
            video.play();
        });
    } else {
        alert("HLS is not supported in your browser")
    }

    let btn = document.getElementById('set_url');
    btn.addEventListener('click', function () {
        var hls = new Hls();
        hls.loadSource(document.getElementById('url').value);
        hls.attachMedia(video);
        hls.on(Hls.Events.MANIFEST_PARSED, function () {
            video.play();
        });
    }, false);

    let subtitles = document.getElementById('subtitles');

    let lastAddedTsToChart = -1;

    window.setInterval(function () {
        let video = document.getElementById('video');
        if (chart != null && emotions.length !== 0) {
            let currentTime = parseFloat(video.currentTime);
            for (let i = 0; i < emotions.length; i++) {
                if (currentTime > emotions[i].ts && lastAddedTsToChart < emotions[i].ts) {
                    chart.data.datasets[0].data.push(emotions[i].data.happy)
                    chart.data.labels.push(emotions[i].original)
                    lastAddedTsToChart = emotions[i].ts
                    chart.update()
                }
            }
        }
    }, 300);

    window.setInterval(function () {
        let video = document.getElementById('video');
        if (text.length !== 0 && document.getElementById('highlightState').checked) {
            let currentTime = parseFloat(video.currentTime);
            subtitles.innerText = '';
            let speakerTag = text[0].speakerTag;
            let speakerText = '';
            for (let index = 0; index < text.length; index++) {
                if (text[index].endTime <= currentTime) {
                    if (speakerTag === text[index].speakerTag) {
                        speakerText += text[index].word + ' ';
                    } else {
                        subtitles.innerHTML += '<p style="color: ' + colors[speakerTag] + '">' + speakerText + '</p>';
                        speakerText = ''
                    }
                    speakerTag = text[index].speakerTag
                }
            }
            if (speakerText !== '') {
                subtitles.innerHTML += '<p style="color: ' + colors[speakerTag] + '">' + speakerText + '</p>';
            }
        } else if (text.length !== 0) {
            let foundText = null;
            let currentTime = parseFloat(video.currentTime);
            let line = '';
            subtitles.innerText = '';
            for (let index = 0; index < text.length; index++) {
                if (text[index].endTime <= currentTime) {
                    foundText = text[index].word;
                    line += ' ' + foundText;
                }
            }
            subtitles.innerText = line;
        }
    }, 100)

    function loadJSON(filename, callback) {
        let xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', filename, true);
        xobj.onreadystatechange = function () {
            if (xobj.readyState == 4 && xobj.status == "200") {
                callback(xobj.responseText);
            }
        };
        xobj.send(null);
    }


    let ctx = document.getElementById('myChart').getContext('2d');
    chart = new Chart(ctx, {
        // The type of chart we want to create
        type: 'line',

        // The data for our dataset
        data: {
            labels: [],
            datasets: [{
                borderColor: 'rgb(255, 99, 132)',
                data: []
            }]
        },

        // Configuration options go here
        options: {
            title: {
                display: true,
                text: 'Happiness'
            },
            legend: {
                display: false
            }
        }
    });
</script>
</body>
</html>